#!/usr/bin/env python
"""Generate HTML for the landing page based on a spreadsheet of book titles and age classifications."""

import os
import sys
import codecs
import csv
import datetime
import shutil
import subprocess
import urllib2
import json
import shutil
import zipfile
import uuid
import glob
from PIL import Image

# I am having SSL Cert problems
import ssl
ssl._create_default_https_context = ssl._create_unverified_context

# Had trouble with one of the descriptions decoding correctly
reload(sys)
sys.setdefaultencoding("utf-8")

# Header Title Mappings
SPREADSHEET_TITLE_HEADER    = "Title"
SPREADSHEET_AUTHOR_HEADER   = "Author"
OKAY_FOR_12_AND_UNDER       = "OK for 12yo?"
DESCRIPTION_HEADER          = "Description"
COVER_URL_HEADER            = "Cover URL"
EPUB_URL_HEADER             = "EPUB URL"
MTA_CATEGORY_1              = "MTA Category 1"

bin_dir = os.path.split(__file__)[0]
package_dir = os.path.join(bin_dir, "..")
template_dir = os.path.join(bin_dir, "../templates")

INDEX_TEMPLATE = os.path.join(package_dir, "index.html.template")
BOOK_INDEX_TEMPLATE = os.path.join(package_dir, "book_index.html.template")
BOOK_DESC_TEMPLATE = os.path.join(package_dir, "book_desc.html.template")
BOOK_CATEGORY_TEMPLATE = os.path.join(package_dir, "book_category.html.template")
APP_CACHE_HTML = os.path.join(package_dir, "appcache.html")
SIMPLYE_LOGO_TEMPLATE = os.path.join(template_dir, "se_logo.html.template")
MENU_OPEN_BTN_TEMPLATE = os.path.join(template_dir, "menuOpenBtn.html.template")
X_ICON_TEMPLATE = os.path.join(template_dir, "xIconBtn.html.template")
FILES_TO_COPY = ["index.css",
                 "simplyE_logo.png",
                 "simplye.png",
                 "apple_badge.png",
                 "google_badge.png",
                 "amazon_badge.png",
                 "webpub-viewer/dist/sw.js",
                 "webpub-viewer/dist/webpub-viewer.js",
                 "webpub-viewer/node_modules/requirejs/require.js",
                 "webpub-viewer/node_modules/whatwg-fetch/fetch.js",
                 "webpub-viewer/dist/styles/css/main.css",
                 "main.js"
                ]

logo = open(SIMPLYE_LOGO_TEMPLATE).read()
menuOpenBtn = open(MENU_OPEN_BTN_TEMPLATE).read()
xIconBtn = open(X_ICON_TEMPLATE).read()

class GenerateLandingPageScript:

      def __init__(self, publisher_asset_file, csv_file, output_dir):
          self.publisher_asset_file = publisher_asset_file
          self.csv_file = csv_file
          self.output_dir = output_dir
          self.workspace_path = os.path.join(package_dir, "workspace")

      def run(self):
          self.clean_and_create_workspace()
          self.download_and_extract_publisher_assets()
          if not os.path.exists(self.output_dir):
              os.mkdir(self.output_dir)
              os.mkdir(self.output_dir + "/books")
              os.mkdir(self.output_dir + "/covers")
              os.mkdir(self.output_dir + "/book_desc")
              os.mkdir(self.output_dir + "/category")

          # Prepare javascript to copy into the book directories later.
          npm_result = subprocess.call("npm install", cwd=os.path.abspath(os.path.join(package_dir, "webpub-viewer")), shell=True)
          if npm_result != 0:
                raise Exception("Failed to build javascript")

          books_html_home = []
          all_books_description = {}
          mta_category_dict = {}

          with open(self.csv_file) as file:
              reader = csv.DictReader(file)

              for row in reader:
                  title = unicode(row.get(SPREADSHEET_TITLE_HEADER), 'utf-8')

                  adult = True
                  if row.get(OKAY_FOR_12_AND_UNDER) == "Y":
                      adult = False

                  author = unicode(row.get(SPREADSHEET_AUTHOR_HEADER), 'utf-8')
                  cover = row.get(COVER_URL_HEADER)

                  # Get the cover, from either the workspace or the internet
                  # and put it in output_dir/covers/originalfilename.ext

                  #This UUID is helpful in cache-busting
                  book_uuid = str(uuid.uuid4())
                  local_path_to_cover = os.path.join(self.output_dir, 'covers', book_uuid)
                  os.makedirs(local_path_to_cover)
                  if "http" in cover or "https" in cover:
                    remote_cover_content = urllib2.urlopen(cover).read()
                    local_path_to_cover  = os.path.join(local_path_to_cover, os.path.basename(cover))
                    with open(local_path_to_cover, 'w') as local_cover:
                      local_cover.write(remote_cover_content)
                  else:
                    # This cover was extracted in download_and_extract_publisher_assets()
                    workspace_path_to_cover = os.path.join(self.workspace_path, cover)
                    local_path_to_cover     = os.path.join(local_path_to_cover, cover)
                    shutil.copy(workspace_path_to_cover, local_path_to_cover)

                  cover_src = os.path.join('covers', book_uuid, os.path.basename(local_path_to_cover))
                  download = row.get(EPUB_URL_HEADER)
                  temp_file = ""

                  description = row.get(DESCRIPTION_HEADER).encode('utf-8', 'ignore')
                  mta_category = row.get(MTA_CATEGORY_1)

                  # Generate the individual webreader for the book
                  folder_name = (title + " - " + author).encode('ascii', 'ignore')

                  if "http" in download or "https" in download:
                      print "Downloading %s." % download
                      remote_epub = urllib2.urlopen(download)
                      content = remote_epub.read()
                      temp_file = os.path.abspath(os.path.join(package_dir, "temp.epub"))
                      with open(temp_file, "w") as local_epub:
                          local_epub.write(content)
                  else:
                      print "Looking for %s locally" % download
                      temp_file = os.path.join(self.workspace_path, download)

                  book_dir = os.path.join(self.output_dir, "books/" + folder_name)
                  export_result = subprocess.call('$GOPATH/bin/webpub-exporter -f %s -o "%s"' % (temp_file, book_dir), shell=True)
                  if export_result != 0:
                      print "Failed to export %s" % download
                      continue

                  # Shim in a page with a call to action
                  manifest_path = os.path.join(book_dir, 'manifest.json')
                  manifest_as_string = open(manifest_path).read()
                  manifest_as_obj = json.loads(manifest_as_string)

                  manifest_as_obj['spine'].append({'type': 'application/html', 'href': 'call-to-action.html'})

                  #  read call-to-action.html as a template and substitute in the Book's title as document title
                  call_to_action_string = open(os.path.join(package_dir, 'call-to-action.html')).read()
                  call_to_action_string = call_to_action_string.replace("{{title}}", title)

                  with codecs.open(os.path.join(book_dir, 'call-to-action.html'), 'w', 'utf-8') as book_specific_call_to_action_file:
                    book_specific_call_to_action_file.write(call_to_action_string)

                  with codecs.open(manifest_path, 'w', 'utf-8') as manifest_file:
                      manifest_file.write(json.dumps(manifest_as_obj))

                  os.remove(temp_file)

                  with open(BOOK_INDEX_TEMPLATE) as template_file:
                      template = template_file.read()
                      out = template.replace("{{title}}", title).replace("{{cover}}", cover)
                      with codecs.open(os.path.join(book_dir, "index.html"), "w", "utf-8") as output_file:
                          output_file.write(out)

                  # For the individual book description pages
                  book_desc_dir = os.path.join(self.output_dir, "book_desc/")
                  book_desc_html = """
                      <div class="book-details">
                        <img src="../%(cover_src)s"  alt="" />
                        <div class="info">
                          <h2 class="title">%(title)s</h2>
                          <div class="author">%(author)s</div>
                        </div>
                      </div>
                      <a href="../books/%(folder_name)s/index.html" title="%(title)s" class="read-now">
                        START READING
                      </a>
                      <div class="book_desc">
                        <div class="read-time">4 hour read</div>
                        <div class="social-media-share"></div>
                        <div class="description-text">
                          %(description)s
                        </div>
                        <a href="../category/%(mta_category)s.html" class="back-to-category">
                          More %(mta_category)s &gt;
                        </a>
                      </div>
                  """ % {
                      "title": title,
                      "author": author,
                      "cover_src": cover_src,
                      "folder_name": folder_name,
                      "description": description,
                      "mta_category": mta_category
                  }

                  # Adding individual book titles and descriptions to dictionary to render later
                  all_books_description[title + " - " + author] = {
                      "title": title,
                      "book_desc_html": book_desc_html
                  }

                  with open(APP_CACHE_HTML) as appcache_file:
                        html = appcache_file.read()
                        with open(os.path.join(book_dir, "appcache.html"), "w") as output_file:
                              output_file.write(html)

                  with open(os.path.join(book_dir, "manifest.appcache")) as manifest_file:
                      manifest = manifest_file.read()

                  manifest_list = "index.html\n"
                  manifest_list += "call-to-action.html\n"

                  for file_to_copy in FILES_TO_COPY:
                      path = os.path.join(package_dir, file_to_copy)
                      shutil.copy(path, self.output_dir)
                      manifest_list += "../../" + file_to_copy.split("/")[-1] + "\n"

                  manifest = manifest.replace("index.html\n", manifest_list)
                  with open(os.path.join(book_dir, "manifest.appcache"), "w") as manifest_file:
                        manifest_file.write(manifest)

                  # This is the markup for a single book on the homepage
                  book_html_home = """
                    <li>
                      <a href="./book_desc/%(title)s - %(author)s.html" title="%(title)s" class="%(class)s">
                        <img src="%(cover_src)s" alt="" />
                        <div class="info">
                          <div class="title">%(title)s</div>
                          <div class="author">%(author)s</div>
                        </div>
                      </a>
                    </li>
                  """ % {
                      "title": title,
                      "author": author,
                      "cover_src": cover_src,
                      "folder_name": folder_name,
                      "class": "adult"# if adult else ""
                  }

                  # This is the markup for a single book on a category page
                  book_html_category = """
                    <li>
                      <img src="../%(cover_src)s" alt="" />
                      <div class="info book_desc">
                        <h2 class="title">%(title)s</h2>
                        <div class="author">%(author)s</div>
                        <p>Short description</p>
                        <div class="read-time">4 hour read</div>
                        <div class="book-links">
                          <a href="../books/%(folder_name)s/index.html" title="%(title)s">
                            READ
                          </a>
                          <a href="../book_desc/%(title)s - %(author)s.html" title="%(title)s">
                            LEARN MORE
                          </a>
                        </div>
                      </div>
                    </li>
                  """ % {
                      "title": title,
                      "author": author,
                      "cover_src": cover_src,
                      "folder_name": folder_name,
                      "class": "adult"# if adult else ""
                  }

                  # Insert the call to action after the third book in each category
                  if mta_category in mta_category_dict and mta_category_dict[mta_category]["count"] == 2:
                      book_html_category += """
                        <li class="call-to-action">
                          <p>Library Underground is a small collection from over 300,000 free eBooks
                          available from SimplyE, a free app from The Public Libraries of New York City.</p>
                          <p>Download for free</p>
                          <div>
                            <a href="https://itunes.apple.com/us/app/nypl-simplye/id1046583900?mt=8" title="Download on the App Store"><img src="../apple_badge.png" alt="Download on the App Store"/></a>
                            <a href="https://play.google.com/store/apps/details?id=org.nypl.simplified.simplye&hl=en" title="Get it on Google Play"><img src="../google_badge.png" alt="Get it on Google Play"/></a>
                          </div>
                        </li>
                      """

                  # Organize the book by its category
                  if mta_category in mta_category_dict:
                      mta_category_dict[mta_category]["home"] += book_html_home
                      mta_category_dict[mta_category]["category"] += book_html_category
                      mta_category_dict[mta_category]["count"] += 1
                  else:
                      mta_category_dict[mta_category] = {
                          "home": book_html_home,
                          "category": book_html_category,
                          "count": 1
                      }

          category_nav_home = []
          category_nav = []
          mta_category_page = {}
          category_count = 0

          # Generate the book lanes and insert a call to action for SimplyE on the homepage
          for category_key in mta_category_dict:
              category_count += 1

              if category_count == 3:
                  books_html_home += """
                    <li class="call-to-action">
                      <p>Library Underground is a small collection from over 300,000 free eBooks
                      available from SimplyE, a free app from The Public Libraries of New York City.</p>
                      <p>Download for free</p>
                      <div>
                        <a href="https://itunes.apple.com/us/app/nypl-simplye/id1046583900?mt=8" title="Download on the App Store"><img src="apple_badge.png" alt="Download on the App Store"/></a>
                        <a href="https://play.google.com/store/apps/details?id=org.nypl.simplified.simplye&hl=en" title="Get it on Google Play"><img src="google_badge.png" alt="Get it on Google Play"/></a>
                      </div>
                    </li>
                  """

              books_html_home += """
                <li class="category-lane">
                  <div class="category-header">
                    <a href="./category/%(category_key)s.html">
                      <h2>%(category_key)s</h2>
                      <span>See all &gt;</span>
                    </a>
                  </div>
                  <div class="lane-container">
                    <ul class="books">
                      %(books)s
                    </ul>
                  </div>
                </li>
              """ % {
                  "category_key": category_key,
                  "books": mta_category_dict[category_key]["home"]
              }

              # Generate the main navigation from all the category titles
              category_nav += """
                <li><a href="../category/%(category_key)s.html">%(category_key)s</a></li>
              """ % {
                  "category_key": category_key
              }

              # Generate the main navigation for the homepage - different base directory
              category_nav_home += """
                <li><a href="./category/%(category_key)s.html">%(category_key)s</a></li>
              """ % {
                  "category_key": category_key
              }

              # Generate the individual category page and the books in it
              category_page = """
                <div class="category-title">
                  <h2>%(category_key)s</h2>
                </div>
                <ul>
                  %(books)s
                </ul>
              """ % {
                  "category_key": category_key,
                  "books": mta_category_dict[category_key]["category"]
              }

              mta_category_page[category_key] = category_page

          cacheManifest = "CACHE MANIFEST\n #timestamp "
          cacheManifest += str(datetime.datetime.utcnow())
          cacheManifest += "\n\n"

          # Generate all individual category pages
          book_category_dir = os.path.join(self.output_dir, "category/")
          for category_key in mta_category_page:
              with open(BOOK_CATEGORY_TEMPLATE) as template_file:
                  template = template_file.read()
                  out = template.replace("{{category}}", category_key).replace("{{category_nav}}", "".join(category_nav)).replace("{{book_category}}", "".join(mta_category_page[category_key])).replace("{{logo}}", logo).replace("{{menuOpenBtn}}", menuOpenBtn).replace("{{xIconBtn}}", xIconBtn)

                  with codecs.open(os.path.join(book_category_dir, category_key + ".html"), 'w', "utf-8") as output_file:
                      output_file.write(out)

          # Generate all individual book description pages
          for book in all_books_description:
              with open(BOOK_DESC_TEMPLATE) as template_file:
                  template = template_file.read()
                  out = template.replace("{{title}}", all_books_description[book]['title']).replace("{{book_desc_html}}", all_books_description[book]['book_desc_html']).replace("{{category_nav}}", "".join(category_nav)).replace("{{logo}}", logo).replace("{{menuOpenBtn}}", menuOpenBtn).replace("{{xIconBtn}}", xIconBtn)

                  with codecs.open(os.path.join(book_desc_dir, book + ".html"), 'w', "utf-8") as output_file:
                      output_file.write(out)

          with open(INDEX_TEMPLATE) as template_file:
              template = template_file.read()
              out = template.replace("{{all_books}}", "".join(books_html_home)).replace("{{category_nav}}", "".join(category_nav_home)).replace("{{logo}}", logo).replace("{{menuOpenBtn}}", menuOpenBtn).replace("{{xIconBtn}}", xIconBtn)

              with codecs.open(os.path.join(self.output_dir, "index.html"), 'w', "utf-8") as output_file:
                  output_file.write(out)

              cacheManifest += "index.html\n"

          for file_to_copy in FILES_TO_COPY:
              path = os.path.join(package_dir, file_to_copy)
              shutil.copy(path, self.output_dir)
              cacheManifest += file_to_copy.split("/")[-1] + "\n"

          cacheManifest += "\nNETWORK:\n*\n"

          with open(os.path.join(self.output_dir, "manifest.appcache"), "w") as output_file:
                output_file.write(cacheManifest)

          self.optimize_covers()

      def optimize_covers(self):
          print "...Optimizing book cover sizes"
          for cover_path in glob.glob(self.output_dir + "/covers/**/*"):
              image = Image.open(cover_path)
              image.thumbnail([195,20000])
              image.save(cover_path)

      def clean_and_create_workspace(self):
          if os.path.exists(self.workspace_path):
            shutil.rmtree(self.workspace_path)
          print "Creating a fresh workspace"
          os.mkdir(self.workspace_path)

      def download_and_extract_publisher_assets(self):
          print "Downloading ZIPs from %s" % self.publisher_asset_file
          with open(self.publisher_asset_file) as file:
              reader = csv.DictReader(file)
              for row in reader:
                  url = row["URL to ZIP containing EPUBs and covers"]
                  basename = os.path.basename(url)

                  print "downloading %s to workspace" % url
                  content = urllib2.urlopen(url).read()
                  zip_path = os.path.join(self.workspace_path, basename+".zip")

                  # write local zip
                  with open(zip_path, "w") as local_zip:
                     local_zip.write(content)

                  # defale zip into workspace
                  print "...extracting"
                  with zipfile.ZipFile(zip_path,"r") as zip_ref:
                     zip_ref.extractall(self.workspace_path)


if len(sys.argv) != 4:
   raise Exception("Usage: bin/generate_landing_page <publisher_asset_file_name> <book_spreadsheet> <output_directory>")

publisher_asset_file = sys.argv[1]
book_csv_file        = sys.argv[2]
output_dir           = sys.argv[3]


GenerateLandingPageScript(publisher_asset_file, book_csv_file, output_dir).run()
