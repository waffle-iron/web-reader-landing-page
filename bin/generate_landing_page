#!/usr/bin/env python
"""Generate HTML for the landing page based on a spreadsheet of book titles and age classifications."""

import os
import sys
import codecs
import csv
import datetime
import shutil
import subprocess
import urllib2
import json
import shutil
import zipfile

# I am having SSL Cert problems
import ssl
ssl._create_default_https_context = ssl._create_unverified_context

# Header Title Mappings
SPREADSHEET_TITLE_HEADER    = "Title"
SPREADSHEET_AUTHOR_HEADER   = "Author"
OKAY_FOR_12_AND_UNDER       = "OK for 12yo?"
DESCRIPTION_HEADER          = "Description"
COVER_URL_HEADER            = "Cover URL"
EPUB_URL_HEADER             = "EPUB URL"

bin_dir = os.path.split(__file__)[0]
package_dir = os.path.join(bin_dir, "..")

INDEX_TEMPLATE = os.path.join(package_dir, "index.html.template")
BOOK_INDEX_TEMPLATE = os.path.join(package_dir, "book_index.html.template")
APP_CACHE_HTML = os.path.join(package_dir, "appcache.html")
FILES_TO_COPY = ["index.css",
                 "simplyE_logo.png",
                 "simplye.png",
                 "apple_badge.png",
                 "google_badge.png",
                 "amazon_badge.png",
                 "webpub-viewer/dist/sw.js",
                 "webpub-viewer/dist/webpub-viewer.js",
                 "webpub-viewer/node_modules/requirejs/require.js",
                 "webpub-viewer/node_modules/whatwg-fetch/fetch.js",
                 "webpub-viewer/dist/styles/css/main.css",
                ]

class GenerateLandingPageScript:

      def __init__(self, publisher_asset_file, csv_file, output_dir):
          self.publisher_asset_file = publisher_asset_file
          self.csv_file = csv_file
          self.output_dir = output_dir
          self.workspace_path = os.path.join(package_dir, "workspace")

      def run(self):
          self.clean_and_create_workspace()
          self.download_and_extract_publisher_assets()

          if not os.path.exists(self.output_dir):
              os.mkdir(self.output_dir)
              os.mkdir(self.output_dir + "/books")
              os.mkdir(self.output_dir + "/covers")

          # Prepare javascript to copy into the book directories later.
          npm_result = subprocess.call("npm install", cwd=os.path.abspath(os.path.join(package_dir, "webpub-viewer")), shell=True)
          if npm_result != 0:
                raise Exception("Failed to build javascript")

          books_html = []

          with open(self.csv_file) as file:
              reader = csv.DictReader(file)

              for row in reader:
                  title = unicode(row.get(SPREADSHEET_TITLE_HEADER), 'utf-8')

                  adult = True
                  if row.get(OKAY_FOR_12_AND_UNDER) == "Y":
                      adult = False

                  author = unicode(row.get(SPREADSHEET_AUTHOR_HEADER), 'utf-8')
                  cover = row.get(COVER_URL_HEADER)

                  # Get the cover, from either the workspace or the internet
                  # and put it in output_dir/covers/originalfilename.ext
                  local_path_to_cover = ""

                  if "http" in cover or "https" in cover:
                    remote_cover_content = urllib2.urlopen(cover).read()
                    local_path_to_cover  = os.path.join(self.output_dir, 'covers', os.path.basename(cover))
                    with open(local_path_to_cover, 'w') as local_cover:
                      local_cover.write(remote_cover_content)
                  else:
                    # This cover was extracted in download_and_extract_publisher_assets()
                    workspace_path_to_cover = os.path.join(self.workspace_path, cover)
                    local_path_to_cover     = os.path.join(self.output_dir, 'covers', cover)
                    shutil.copy(workspace_path_to_cover, local_path_to_cover)

                  cover_src = "covers/" + os.path.basename(local_path_to_cover)
                  download = row.get(EPUB_URL_HEADER)
                  temp_file = ""
                  folder_name = (title + " - " + author).encode('ascii', 'ignore')

                  if "http" in download or "https" in download:
                      print "Downloading %s." % download
                      remote_epub = urllib2.urlopen(download)
                      content = remote_epub.read()
                      temp_file = os.path.abspath(os.path.join(package_dir, "temp.epub"))
                      with open(temp_file, "w") as local_epub:
                          local_epub.write(content)
                  else:
                      print "Looking for %s locally" % download
                      temp_file = os.path.join(self.workspace_path, download)

                  book_dir = os.path.join(self.output_dir, "books/" + folder_name)
                  export_result = subprocess.call('$GOPATH/bin/webpub-exporter -f %s -o "%s"' % (temp_file, book_dir), shell=True)
                  if export_result != 0:
                      print "Failed to export %s" % download
                      continue

                  # Shim in a page with a call to action
                  manifest_path = os.path.join(book_dir, 'manifest.json')
                  manifest_as_string = open(manifest_path).read()
                  manifest_as_obj = json.loads(manifest_as_string)

                  manifest_as_obj['spine'].append({'type': 'application/html', 'href': 'call-to-action.html'})

                  #  read call-to-action.html as a template and substitute in the Book's title as document title
                  call_to_action_string = open(os.path.join(package_dir, 'call-to-action.html')).read()
                  call_to_action_string = call_to_action_string.replace("{{title}}", title)

                  with codecs.open(os.path.join(book_dir, 'call-to-action.html'), 'w', 'utf-8') as book_specific_call_to_action_file:
                    book_specific_call_to_action_file.write(call_to_action_string)

                  with codecs.open(manifest_path, 'w', 'utf-8') as manifest_file:
                      manifest_file.write(json.dumps(manifest_as_obj))

                  os.remove(temp_file)

                  with open(BOOK_INDEX_TEMPLATE) as template_file:
                      template = template_file.read()
                      out = template.replace("{{title}}", title).replace("{{cover}}", cover)
                      with codecs.open(os.path.join(book_dir, "index.html"), "w", "utf-8") as output_file:
                          output_file.write(out)

                  with open(APP_CACHE_HTML) as appcache_file:
                        html = appcache_file.read()
                        with open(os.path.join(book_dir, "appcache.html"), "w") as output_file:
                              output_file.write(html)

                  with open(os.path.join(book_dir, "manifest.appcache")) as manifest_file:
                      manifest = manifest_file.read()

                  manifest_list = "index.html\n"
                  manifest_list += "call-to-action.html\n"

                  for file_to_copy in FILES_TO_COPY:
                      path = os.path.join(package_dir, file_to_copy)
                      shutil.copy(path, self.output_dir)
                      manifest_list += "../../" + file_to_copy.split("/")[-1] + "\n"

                  manifest = manifest.replace("index.html\n", manifest_list)
                  with open(os.path.join(book_dir, "manifest.appcache"), "w") as manifest_file:
                        manifest_file.write(manifest)

                  book_html = """
                  <a href="books/%(folder_name)s/index.html" title="%(title)s" class="%(class)s">
                    <img src="%(cover_src)s" alt="%(title)s" />
                    <div class="info">
                      <div class="title">%(title)s</div>
                      <div class="author">%(author)s</div>
                    </div>
                  </a>
                  """ % {
                      "title": title,
                      "author": author,
                      "cover_src": cover_src,
                      "folder_name": folder_name,
                      "class": "adult" if adult else ""
                  }

                  books_html += book_html

          cacheManifest = "CACHE MANIFEST\n #timestamp "
          cacheManifest += str(datetime.datetime.utcnow())
          cacheManifest += "\n\n"

          with open(INDEX_TEMPLATE) as template_file:
              template = template_file.read()
              out = template.replace("{{all_books}}", "".join(books_html))

              with codecs.open(os.path.join(self.output_dir, "index.html"), 'w', "utf-8") as output_file:
                  output_file.write(out)

              cacheManifest += "index.html\n"

          for file_to_copy in FILES_TO_COPY:
              path = os.path.join(package_dir, file_to_copy)
              shutil.copy(path, self.output_dir)
              cacheManifest += file_to_copy.split("/")[-1] + "\n"

          cacheManifest += "\nNETWORK:\n*\n"

          with open(os.path.join(self.output_dir, "manifest.appcache"), "w") as output_file:
                output_file.write(cacheManifest)

      def clean_and_create_workspace(self):
          if os.path.exists(self.workspace_path):
            shutil.rmtree(self.workspace_path)
          print "Creating a fresh workspace"
          os.mkdir(self.workspace_path)

      def download_and_extract_publisher_assets(self):
          print "Downloading ZIPs from %s" % self.publisher_asset_file
          with open(self.publisher_asset_file) as file:
              reader = csv.DictReader(file)
              for row in reader:
                  url = row["URL to ZIP containing EPUBs and covers"]
                  basename = os.path.basename(url)

                  print "downloading %s to workspace" % url
                  content = urllib2.urlopen(url).read()
                  zip_path = os.path.join(self.workspace_path, basename+".zip")

                  # write local zip
                  with open(zip_path, "w") as local_zip:
                     local_zip.write(content)

                  # defale zip into workspace
                  print "...extracting"
                  with zipfile.ZipFile(zip_path,"r") as zip_ref:
                     zip_ref.extractall(self.workspace_path)


if len(sys.argv) != 4:
   raise Exception("Usage: bin/generate_landing_page <publisher_asset_file_name> <book_spreadsheet> <output_directory>")

publisher_asset_file = sys.argv[1]
book_csv_file        = sys.argv[2]
output_dir           = sys.argv[3]


GenerateLandingPageScript(publisher_asset_file, book_csv_file, output_dir).run()
